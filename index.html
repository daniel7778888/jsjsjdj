<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, user-scalable=no, maximum-scale=1.0">
    <title>DOTA Mobile Online</title>
    <!-- –ë–∏–±–ª–∏–æ—Ç–µ–∫–∞ Socket.IO –¥–ª—è –º—É–ª—å—Ç–∏–ø–ª–µ–µ—Ä–∞ -->
    <script src="/socket.io/socket.io.js"></script>
    <script src="https://cdnjs.cloudflare.com/ajax/libs/three.js/r128/three.min.js"></script>
    <style>
        * { margin: 0; padding: 0; box-sizing: border-box; touch-action: none; -webkit-user-select: none; user-select: none; }
        body { overflow: hidden; background: #0a0a12; font-family: 'Segoe UI', sans-serif; }
        #gameCanvas { width: 100vw; height: 100vh; display: block; }
        
        /* UI Eements */
        #heroSelect, #settingsModal {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%;
            background: linear-gradient(135deg, #0a0a15 0%, #1a1a2e 50%, #0a0a15 100%);
            z-index: 2000; display: flex; flex-direction: column; align-items: center; justify-content: center;
        }
        #settingsModal { background: rgba(0,0,0,0.85); display: none; z-index: 3000; }

        .select-title { color: #4af; font-size: 28px; font-weight: bold; margin-bottom: 20px; text-shadow: 0 0 20px #4af; }
        .heroes-grid { display: grid; grid-template-columns: repeat(2, 1fr); gap: 15px; max-width: 400px; }
        .hero-card {
            background: rgba(30, 40, 60, 0.9); border: 2px solid #446688; border-radius: 12px;
            padding: 15px; cursor: pointer; text-align: center; color: white;
        }
        .hero-icon { font-size: 30px; margin-bottom: 5px; }
        
        /* Settings UI */
        .settings-panel {
            background: #1a1a24; border: 2px solid #4af; border-radius: 15px; padding: 25px;
            width: 300px; text-align: center;
        }
        .setting-row { margin-bottom: 20px; }
        .setting-label { color: #888; font-size: 14px; margin-bottom: 8px; display: block; }
        .btn-group { display: flex; gap: 5px; justify-content: center; }
        .btn-opt {
            background: #222; color: #fff; border: 1px solid #444; padding: 8px 12px;
            border-radius: 6px; cursor: pointer; flex: 1; font-size: 12px;
        }
        .btn-opt.active { background: #4af; border-color: #4af; color: #000; font-weight: bold; }
        .close-btn {
            margin-top: 10px; background: #c33; border: none; padding: 10px 30px;
            color: white; border-radius: 8px; font-weight: bold;
        }
        
        #settingsBtn {
            position: fixed; top: 15px; right: 140px; width: 40px; height: 40px;
            background: rgba(0,0,0,0.5); border: 2px solid #555; border-radius: 8px;
            color: #fff; font-size: 24px; display: none; align-items: center; justify-content: center;
            cursor: pointer; z-index: 1000;
        }

        /* Joystick */
        #joystickZone {
            position: fixed; bottom: 50px; left: 50px; width: 120px; height: 120px;
            z-index: 1000; display: none; /* Controlled by JS */
        }
        .joystick-bg {
            width: 100%; height: 100%; border-radius: 50%; background: rgba(255, 255, 255, 0.1);
            border: 2px solid rgba(255, 255, 255, 0.3); position: relative;
        }
        .joystick-stick {
            width: 50px; height: 50px; border-radius: 50%; background: rgba(70, 170, 255, 0.8);
            position: absolute; top: 50%; left: 50%; transform: translate(-50%, -50%);
            box-shadow: 0 0 10px #4af; pointer-events: none;
        }

        /* UI Game */
        #ui { position: fixed; top: 0; left: 0; width: 100%; height: 100%; pointer-events: none; display: none; }
        
        /* Reuse existing UI styles (MiniMap, Skills, etc.) - Compacted */
        .minimap { position: absolute; top: 15px; right: 15px; width: 100px; height: 100px; background: rgba(0,0,0,0.8); border: 1px solid #4af; }
        .minimap-dot { position: absolute; width: 6px; height: 6px; border-radius: 50%; transform: translate(-50%, -50%); }
        .abilities-panel {
            position: absolute; bottom: 20px; left: 50%; transform: translateX(-50%);
            display: flex; gap: 10px; pointer-events: auto;
        }
        .ability {
            width: 55px; height: 55px; border-radius: 10px; background: #222; border: 2px solid #555;
            display: flex; align-items: center; justify-content: center; font-size: 24px; position: relative;
        }
        .ability.selected { border-color: #fff; box-shadow: 0 0 15px #fff; transform: scale(1.1); }
        .ability-cd { 
            position: absolute; top:0; left:0; width:100%; height:100%; background:rgba(0,0,0,0.8);
            color:#fff; display:flex; align-items:center; justify-content:center; border-radius:8px; opacity:0;
        }
        .ability-cd.active { opacity: 1; }
        
        .hero-info { position: absolute; top: 15px; left: 15px; }
        .hero-bar { width: 150px; height: 16px; background: #111; border: 1px solid #444; margin-bottom: 4px; position: relative; }
        .hero-bar-fill { height: 100%; transition: width 0.2s; }
        .hp-fill { background: #2c5; } .mp-fill { background: #38f; }
        
        .cancel-btn { 
            position: absolute; bottom: 100px; left: 50%; transform: translateX(-50%);
            background: #a33; padding: 8px 20px; border-radius: 8px; color: white;
            pointer-events: auto; display: none; font-weight: bold;
        }
        .cancel-btn.active { display: block; }

        /* Loading */
        #loading {
            position: fixed; top: 0; left: 0; width: 100%; height: 100%; background: #0a0a15;
            display: none; align-items: center; justify-content: center; color: #4af; font-size: 24px; z-index: 2500;
        }
    </style>
</head>
<body>
    <!-- Main Menu -->
    <div id="heroSelect">
        <div class="select-title">DOTA MOBILE</div>
        <div style="color: #888; margin-bottom: 20px;">–û–Ω–ª–∞–π–Ω —Ä–µ–∂–∏–º</div>
        <div class="heroes-grid">
            <div class="hero-card" onclick="startGame('fire')"><div class="hero-icon">üî•</div>–ò–Ω—Ñ–µ—Ä–Ω–æ</div>
            <div class="hero-card" onclick="startGame('ice')"><div class="hero-icon">‚ùÑÔ∏è</div>–§—Ä–æ—Å—Ç–∏—è</div>
            <div class="hero-card" onclick="startGame('storm')"><div class="hero-icon">‚ö°</div>–í–æ–ª—å—Ç–µ–∫—Å</div>
            <div class="hero-card" onclick="startGame('shadow')"><div class="hero-icon">üíÄ</div>–£–º–±—Ä–∞</div>
        </div>
    </div>

    <!-- Settings Modal -->
    <div id="settingsModal">
        <div class="settings-panel">
            <div class="select-title" style="font-size: 20px;">–ù–ê–°–¢–†–û–ô–ö–ò</div>
            
            <div class="setting-row">
                <span class="setting-label">–ì–†–ê–§–ò–ö–ê</span>
                <div class="btn-group">
                    <div class="btn-opt" onclick="setGraphics('low')" id="gfx-low">–ù–ò–ó–ö–ê–Ø</div>
                    <div class="btn-opt" onclick="setGraphics('med')" id="gfx-med">–°–†–ï–î–ù–Ø–Ø</div>
                    <div class="btn-opt active" onclick="setGraphics('high')" id="gfx-high">–í–´–°–û–ö–ê–Ø</div>
                </div>
            </div>

            <div class="setting-row">
                <span class="setting-label">–£–ü–†–ê–í–õ–ï–ù–ò–ï</span>
                <div class="btn-group">
                    <div class="btn-opt active" onclick="setControl('tap')" id="ctrl-tap">–¢–ê–ü–´</div>
                    <div class="btn-opt" onclick="setControl('joy')" id="ctrl-joy">–î–ñ–û–ô–°–¢–ò–ö</div>
                </div>
            </div>

            <button class="close-btn" onclick="toggleSettings()">–ó–ê–ö–†–´–¢–¨</button>
        </div>
    </div>

    <div id="loading">–ü–û–î–ö–õ–Æ–ß–ï–ù–ò–ï...</div>
    <canvas id="gameCanvas"></canvas>
    
    <!-- Joystick UI -->
    <div id="joystickZone">
        <div class="joystick-bg">
            <div class="joystick-stick" id="joyStick"></div>
        </div>
    </div>

    <!-- Game UI -->
    <div id="settingsBtn" onclick="toggleSettings()">‚öôÔ∏è</div>
    <div id="ui">
        <div class="hero-info">
            <div style="color:white; font-weight:bold; margin-bottom:4px;" id="playerName">–ì–µ—Ä–æ–π</div>
            <div class="hero-bar"><div class="hero-bar-fill hp-fill" id="hpBar" style="width: 100%"></div></div>
            <div class="hero-bar"><div class="hero-bar-fill mp-fill" id="mpBar" style="width: 100%"></div></div>
        </div>
        
        <div class="minimap">
            <div class="minimap-dot" style="background:#4af" id="mmHero"></div>
            <!-- Other players dots will be added dynamically -->
        </div>

        <div class="abilities-panel" id="abilitiesPanel"></div>
        <div class="cancel-btn" id="cancelBtn">–û–¢–ú–ï–ù–ê</div>
    </div>

    <script>
        // === SOCKET.IO ===
        const socket = io();
        let mySocketId = null;
        let isHost = false;
        let otherPlayers = {}; // –•—Ä–∞–Ω–µ–Ω–∏–µ –º–µ—à–µ–π –¥—Ä—É–≥–∏—Ö –∏–≥—Ä–æ–∫–æ–≤

        // === CONFIG & STATE ===
        const CONFIG = { MAP_SIZE: 50, HERO_SPEED: 0.12 };
        const state = {
            hp: 500, maxHp: 500, mp: 500, maxMp: 500,
            moveTarget: null, selectedAbility: null, isDragging: false,
            cooldowns: { 0:0, 1:0, 2:0, 3:0 },
            heroType: 'fire',
            joystickActive: false,
            joystickVector: { x: 0, y: 0 }
        };
        
        // Settings State
        let settings = { graphics: 'high', control: 'tap' };

        // === HERO DATA ===
        const HEROES = {
            fire: { color: 0xff6633, hp: 550, abilities: ['‚òÑÔ∏è','üî•','üí£','ü¶Ö'] },
            ice: { color: 0x44aaff, hp: 500, abilities: ['üå®Ô∏è','üßä','üåä','‚ùÑÔ∏è'] },
            storm: { color: 0xaa66ff, hp: 480, abilities: ['‚ö°','üîó','üí®','üå™Ô∏è'] },
            shadow: { color: 0x44ff88, hp: 600, abilities: ['üëª','ü¶á','üåÄ','üï≥Ô∏è'] }
        };

        // === THREE.JS SETUP ===
        const canvas = document.getElementById('gameCanvas');
        const renderer = new THREE.WebGLRenderer({ canvas, antialias: true });
        renderer.setSize(window.innerWidth, window.innerHeight);
        renderer.shadowMap.enabled = true; // Default high

        const scene = new THREE.Scene();
        scene.background = new THREE.Color(0x0a0a12);
        
        const camera = new THREE.PerspectiveCamera(50, window.innerWidth/window.innerHeight, 0.1, 100);
        camera.position.set(0, 25, 20);
        camera.lookAt(0, 0, 0);

        // Lighting
        const ambientLight = new THREE.AmbientLight(0x404040, 1);
        scene.add(ambientLight);
        const dirLight = new THREE.DirectionalLight(0xffffff, 1);
        dirLight.position.set(10, 30, 10);
        dirLight.castShadow = true;
        dirLight.shadow.mapSize.width = 2048;
        dirLight.shadow.mapSize.height = 2048;
        scene.add(dirLight);

        // Floor
        const floor = new THREE.Mesh(
            new THREE.PlaneGeometry(CONFIG.MAP_SIZE, CONFIG.MAP_SIZE),
            new THREE.MeshStandardMaterial({ color: 0x151520, roughness: 0.8 })
        );
        floor.rotation.x = -Math.PI/2;
        floor.receiveShadow = true;
        scene.add(floor);
        scene.add(new THREE.GridHelper(CONFIG.MAP_SIZE, 25, 0x334455, 0x223344));

        // === GAME OBJECTS ===
        let hero = null;
        let moveIndicator = new THREE.Mesh(
            new THREE.RingGeometry(0.3, 0.4, 16),
            new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 })
        );
        moveIndicator.rotation.x = -Math.PI/2;
        moveIndicator.visible = false;
        scene.add(moveIndicator);
        
        const bots = []; // Bot meshes
        let botData = []; // Bot logic data

        // === FUNCTIONS ===

        function createHeroMesh(type, isMine = false) {
            const data = HEROES[type];
            const group = new THREE.Group();
            
            const body = new THREE.Mesh(
                new THREE.CylinderGeometry(0.4, 0.4, 1.6, 12),
                new THREE.MeshStandardMaterial({ color: data.color })
            );
            body.position.y = 0.8;
            body.castShadow = true;
            group.add(body);
            
            const head = new THREE.Mesh(
                new THREE.SphereGeometry(0.35),
                new THREE.MeshStandardMaterial({ color: 0xffccaa })
            );
            head.position.y = 1.8;
            group.add(head);

            if (isMine) {
                const ring = new THREE.Mesh(
                    new THREE.RingGeometry(0.8, 0.9, 32),
                    new THREE.MeshBasicMaterial({ color: 0x00ff00, transparent: true, opacity: 0.5 })
                );
                ring.rotation.x = -Math.PI/2;
                ring.position.y = 0.05;
                group.add(ring);
            } else {
                // Name tag for others
                // Simplified red ring for enemies/others
                const ring = new THREE.Mesh(
                    new THREE.RingGeometry(0.8, 0.9, 32),
                    new THREE.MeshBasicMaterial({ color: 0xff0000, transparent: true, opacity: 0.5 })
                );
                ring.rotation.x = -Math.PI/2;
                ring.position.y = 0.05;
                group.add(ring);
            }

            scene.add(group);
            return group;
        }

        function createBotMesh() {
            const group = new THREE.Group();
            const body = new THREE.Mesh(
                new THREE.BoxGeometry(0.8, 1.5, 0.8),
                new THREE.MeshStandardMaterial({ color: 0xcc3333 })
            );
            body.position.y = 0.75;
            body.castShadow = true;
            group.add(body);
            scene.add(group);
            return group;
        }

        // === SETTINGS LOGIC ===
        function toggleSettings() {
            const modal = document.getElementById('settingsModal');
            modal.style.display = modal.style.display === 'flex' ? 'none' : 'flex';
        }

        function setGraphics(level) {
            settings.graphics = level;
            document.querySelectorAll('#settingsModal .btn-group:first-child .btn-opt').forEach(b => b.classList.remove('active'));
            document.getElementById('gfx-' + level).classList.add('active');

            if (level === 'high') {
                renderer.setPixelRatio(window.devicePixelRatio);
                renderer.shadowMap.enabled = true;
                dirLight.castShadow = true;
            } else if (level === 'med') {
                renderer.setPixelRatio(1);
                renderer.shadowMap.enabled = false;
                dirLight.castShadow = false;
            } else {
                renderer.setPixelRatio(0.75);
                renderer.shadowMap.enabled = false;
                dirLight.castShadow = false;
            }
            // Recompile materials (hacky update)
            scene.traverse(obj => { if(obj.material) obj.material.needsUpdate = true; });
        }

        function setControl(type) {
            settings.control = type;
            document.querySelectorAll('#settingsModal .btn-group:last-child .btn-opt').forEach(b => b.classList.remove('active'));
            document.getElementById('ctrl-' + type).classList.add('active');
            
            const joy = document.getElementById('joystickZone');
            joy.style.display = type === 'joy' ? 'block' : 'none';
        }

        // === JOYSTICK LOGIC ===
        const joyZone = document.getElementById('joystickZone');
        const stick = document.getElementById('joyStick');
        let joyTouchId = null;
        let joyCenter = { x: 0, y: 0 };

        joyZone.addEventListener('touchstart', e => {
            e.preventDefault();
            const touch = e.changedTouches[0];
            joyTouchId = touch.identifier;
            const rect = joyZone.getBoundingClientRect();
            joyCenter = { x: rect.left + rect.width/2, y: rect.top + rect.height/2 };
            updateJoystick(touch.clientX, touch.clientY);
            state.joystickActive = true;
            state.moveTarget = null; // Disable tap move
        }, {passive: false});

        joyZone.addEventListener('touchmove', e => {
            e.preventDefault();
            for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === joyTouchId) {
                    updateJoystick(e.changedTouches[i].clientX, e.changedTouches[i].clientY);
                    break;
                }
            }
        }, {passive: false});

        const endJoystick = (e) => {
             for(let i=0; i<e.changedTouches.length; i++) {
                if(e.changedTouches[i].identifier === joyTouchId) {
                    state.joystickActive = false;
                    state.joystickVector = {x:0, y:0};
                    stick.style.transform = `translate(-50%, -50%)`;
                    joyTouchId = null;
                    break;
                }
            }
        };
        joyZone.addEventListener('touchend', endJoystick);
        joyZone.addEventListener('touchcancel', endJoystick);

        function updateJoystick(x, y) {
            const dx = x - joyCenter.x;
            const dy = y - joyCenter.y;
            const distance = Math.min(Math.sqrt(dx*dx + dy*dy), 35); // 35px radius limit
            const angle = Math.atan2(dy, dx);
            
            const moveX = Math.cos(angle) * distance;
            const moveY = Math.sin(angle) * distance;
            
            stick.style.transform = `translate(calc(-50% + ${moveX}px), calc(-50% + ${moveY}px))`;
            
            // Normalize vector 0-1
            state.joystickVector = {
                x: moveX / 35,
                y: moveY / 35
            };
        }

        // === GAME INIT ===
        function startGame(type) {
            state.heroType = type;
            state.maxHp = HEROES[type].hp;
            state.hp = state.maxHp;
            
            document.getElementById('heroSelect').style.display = 'none';
            document.getElementById('loading').style.display = 'flex';
            
            // Connect to server
            socket.emit('joinGame', { 
                heroType: type,
                hp: state.hp,
                maxHp: state.maxHp
            });
        }

        // Socket Events
        socket.on('setHost', (val) => {
            isHost = val;
            if(isHost && botData.length === 0) {
                // Init Bots if host
                for(let i=0; i<3; i++) {
                    botData.push({ x: (Math.random()-0.5)*30, z: (Math.random()-0.5)*30, hp: 500 });
                }
            }
        });

        socket.on('currentPlayers', (serverPlayers) => {
            document.getElementById('loading').style.display = 'none';
            document.getElementById('ui').style.display = 'block';
            document.getElementById('settingsBtn').style.display = 'flex';
            
            mySocketId = socket.id;
            
            // Create my hero
            hero = createHeroMesh(state.heroType, true);
            
            // Create others
            Object.values(serverPlayers).forEach(p => {
                if(p.id !== mySocketId) {
                    const other = createHeroMesh(p.heroType, false);
                    other.position.set(p.x, 0, p.z);
                    otherPlayers[p.id] = other;
                }
            });

            // Create Bots visuals
            for(let i=0; i<3; i++) bots.push(createBotMesh());
            
            createAbilitiesUI();
            animate();
        });

        socket.on('newPlayer', (p) => {
            const other = createHeroMesh(p.heroType, false);
            other.position.set(p.x, 0, p.z);
            otherPlayers[p.id] = other;
        });

        socket.on('playerMoved', (p) => {
            if(otherPlayers[p.id]) {
                const mesh = otherPlayers[p.id];
                // Simple interpolation could go here, direct set for now
                mesh.position.set(p.x, 0, p.z);
                mesh.rotation.y = p.rot;
            }
        });

        socket.on('playerDisconnected', (id) => {
            if(otherPlayers[id]) {
                scene.remove(otherPlayers[id]);
                delete otherPlayers[id];
            }
        });

        socket.on('botsSync', (data) => {
            if(!isHost) {
                botData = data;
                // Update visuals
                botData.forEach((b, i) => {
                    if(bots[i]) {
                        bots[i].position.set(b.x, 0, b.z);
                        bots[i].visible = b.hp > 0;
                    }
                });
            }
        });

        socket.on('remoteAbility', (data) => {
            // Visual effect for others abilities
            const caster = otherPlayers[data.id];
            if(caster) {
                showDamage(data.target, "‚ú®", "ability"); // Simplified effect
            }
        });

        // === CONTROLS (TAP) ===
        const raycaster = new THREE.Raycaster();
        
        canvas.addEventListener('mousedown', onPointerDown);
        canvas.addEventListener('touchstart', (e) => {
            if(e.target === canvas) onPointerDown(e.touches[0]);
        }, {passive: false});

        function onPointerDown(e) {
            if(settings.control === 'joy' && state.joystickActive) return;
            if(state.selectedAbility !== null) {
                // Cast logic
                const point = getGroundPoint(e.clientX, e.clientY);
                if(point) castAbility(point);
            } else if (settings.control === 'tap') {
                // Move Logic
                const point = getGroundPoint(e.clientX, e.clientY);
                if(point) {
                    state.moveTarget = point;
                    moveIndicator.position.copy(point);
                    moveIndicator.position.y = 0.1;
                    moveIndicator.visible = true;
                }
            }
        }

        function getGroundPoint(x, y) {
            const mouse = new THREE.Vector2(
                (x / window.innerWidth) * 2 - 1,
                -(y / window.innerHeight) * 2 + 1
            );
            raycaster.setFromCamera(mouse, camera);
            const intersects = raycaster.intersectObject(floor);
            return intersects.length > 0 ? intersects[0].point : null;
        }

        // === ABILITIES ===
        function createAbilitiesUI() {
            const panel = document.getElementById('abilitiesPanel');
            const abils = HEROES[state.heroType].abilities;
            panel.innerHTML = '';
            abils.forEach((icon, i) => {
                const btn = document.createElement('div');
                btn.className = 'ability';
                btn.innerHTML = `${icon}<div class="ability-cd" id="cd${i}"></div>`;
                btn.onclick = (e) => { e.stopPropagation(); selectAbility(i); };
                panel.appendChild(btn);
            });
            
            document.getElementById('cancelBtn').onclick = () => {
                state.selectedAbility = null;
                document.querySelectorAll('.ability').forEach(b => b.classList.remove('selected'));
                document.getElementById('cancelBtn').classList.remove('active');
            };
        }

        function selectAbility(index) {
            if(state.cooldowns[index] > 0) return;
            state.selectedAbility = index;
            document.querySelectorAll('.ability').forEach(b => b.classList.remove('selected'));
            document.querySelectorAll('.ability')[index].classList.add('selected');
            document.getElementById('cancelBtn').classList.add('active');
        }

        function castAbility(targetPos) {
            const idx = state.selectedAbility;
            state.cooldowns[idx] = 5; // Fixed 5s CD for simplicity
            
            // Visuals
            showDamage(targetPos, "üí•", "ability");
            
            // Network
            socket.emit('abilityUsed', { abilityIndex: idx, target: targetPos });
            
            // Logic (Host handles bot damage actually, but for simplicity client checks distance)
            // Ideally server validates, but we do client-side trust for this demo
            if(isHost) {
                botData.forEach(b => {
                    const dx = b.x - targetPos.x;
                    const dz = b.z - targetPos.z;
                    if(Math.sqrt(dx*dx + dz*dz) < 4) { // Radius 4
                        b.hp -= 100;
                    }
                });
                socket.emit('updateBots', botData);
            }

            // Reset
            state.selectedAbility = null;
            document.querySelectorAll('.ability').forEach(b => b.classList.remove('selected'));
            document.getElementById('cancelBtn').classList.remove('active');
        }

        function showDamage(pos, text, type) {
            const div = document.createElement('div');
            div.textContent = text;
            div.style.position = 'absolute';
            div.style.color = type === 'ability' ? '#f0f' : '#fff';
            div.style.fontWeight = 'bold';
            div.style.fontSize = '20px';
            div.style.textShadow = '0 0 5px #000';
            
            // Project 3D to 2D
            const v = pos.clone();
            v.y += 2;
            v.project(camera);
            const x = (v.x * .5 + .5) * window.innerWidth;
            const y = (-(v.y * .5) + .5) * window.innerHeight;
            
            div.style.left = x + 'px';
            div.style.top = y + 'px';
            div.style.transition = 'top 1s, opacity 1s';
            document.body.appendChild(div);
            
            setTimeout(() => {
                div.style.top = (y - 50) + 'px';
                div.style.opacity = 0;
            }, 50);
            setTimeout(() => div.remove(), 1000);
        }

        // === LOOP ===
        let lastTime = 0;
        let updateTimer = 0;

        function animate(time) {
            requestAnimationFrame(animate);
            const delta = (time - lastTime) / 1000 || 0;
            lastTime = time;

            if(!hero) return;

            // Movement Logic
            let moved = false;
            
            if (settings.control === 'joy' && state.joystickActive) {
                // Joystick Move
                const speed = CONFIG.HERO_SPEED * 3; // Boost for joy
                // Rotate vector based on camera? Simplified: Joy Up = World -Z
                hero.position.x += state.joystickVector.x * speed;
                hero.position.z += state.joystickVector.y * speed; // Y on screen is Z in 3D
                hero.lookAt(hero.position.x + state.joystickVector.x, 0.8, hero.position.z + state.joystickVector.y);
                moved = true;
                moveIndicator.visible = false;
            } 
            else if (settings.control === 'tap' && state.moveTarget) {
                // Tap Move
                const dir = new THREE.Vector3().subVectors(state.moveTarget, hero.position);
                dir.y = 0;
                if(dir.length() > 0.2) {
                    dir.normalize();
                    hero.position.add(dir.multiplyScalar(CONFIG.HERO_SPEED));
                    hero.lookAt(state.moveTarget.x, 0.8, state.moveTarget.z);
                    moved = true;
                } else {
                    state.moveTarget = null;
                    moveIndicator.visible = false;
                }
            }

            // Camera Follow
            camera.position.x = hero.position.x;
            camera.position.z = hero.position.z + 20;
            camera.lookAt(hero.position.x, 0, hero.position.z);

            // Network Update (throttle)
            updateTimer += delta;
            if(updateTimer > 0.05 && moved) {
                socket.emit('playerUpdate', {
                    x: hero.position.x,
                    z: hero.position.z,
                    rot: hero.rotation.y,
                    hp: state.hp
                });
                updateTimer = 0;
            }

            // Bots Logic (Host only)
            if(isHost) {
                let botsChanged = false;
                botData.forEach((b, i) => {
                    if(b.hp > 0) {
                        // Simple AI: Move towards hero if close
                        const dx = hero.position.x - b.x;
                        const dz = hero.position.z - b.z;
                        const dist = Math.sqrt(dx*dx + dz*dz);
                        
                        if(dist < 10 && dist > 1.5) {
                            b.x += (dx/dist) * 0.05;
                            b.z += (dz/dist) * 0.05;
                            botsChanged = true;
                        }
                    }
                });
                if(botsChanged) socket.emit('updateBots', botData);
                
                // Update Local Bot Meshes immediately
                botData.forEach((b, i) => {
                   if(bots[i]) {
                       bots[i].position.set(b.x, 0, b.z);
                       bots[i].visible = b.hp > 0;
                   } 
                });
            }

            // Cooldowns
            for(let k in state.cooldowns) {
                if(state.cooldowns[k] > 0) {
                    state.cooldowns[k] -= delta;
                    const el = document.getElementById('cd'+k);
                    if(el) {
                        el.textContent = Math.ceil(state.cooldowns[k]);
                        el.classList.add('active');
                    }
                    if(state.cooldowns[k] <= 0) {
                        if(el) el.classList.remove('active');
                    }
                }
            }

            // Update UI Bars
            document.getElementById('hpBar').style.width = (state.hp/state.maxHp*100)+'%';
            
            // Update MiniMap
            const mapScale = 1; 
            const mmHero = document.getElementById('mmHero');
            mmHero.style.left = (50 + hero.position.x * mapScale) + 'px';
            mmHero.style.top = (50 - hero.position.z * mapScale) + 'px';

            renderer.render(scene, camera);
        }

        window.addEventListener('resize', () => {
            camera.aspect = window.innerWidth / window.innerHeight;
            camera.updateProjectionMatrix();
            renderer.setSize(window.innerWidth, window.innerHeight);
        });
    </script>
</body>
</html>
